
![[Pasted image 20231019102824.png]]

버전을 주,부,수 숫자로 하고

- 주버전 = MAJOR(x): 호환되지 않는 API 변경사항이 있을 때 증가
- 부버전 = MINOR(y): 기존 버전과 호환되면서 새로운 기능이 추가됐을 때 증가
- 수버전 = PATCH(z):  기존 버전과 호환되면서 오류 수정이 일어났을 때 증가



규칙

1.  보통 버전 번호는 반드시 X.Y.Z의 형태로 하고, X, Y, Z는 각각 자연수(음이 아닌 정수)이고, 절대로 0이 앞에 붙어서는 안됩니다. X는 MAJOR(주 버전) 번호이고, Y는 MINOR(부버전) 번호이며, Z는 PATCH(수버전) 번호입니다. 각각은 반드시 증가하는 수여야 합니다. 예: 1.9.0 -> 1.10.0 -> 1.11.0.

2. 특정 버전으로 패키지를 배포하고 나면 , 그 버전의 내용은 절대 변경하지 말아야 합니다. 변경분이 있다면 반드시 새로운 버전으로 배포하도록 합니다.

3. 주버전(Major) 0 ( 0.y.z)은 초기 개발을 위해서 씁니다. 아무 때나 마음대로 바꿀 수 있습니다. 이 공개 API는 안정판으로 보지 않는 게 좋습니다.

4. 수버전 Z 는 ( x, y ,z | x > 0)는 반드시 그전 버전 API와 호환되는 버그 수정의 경우에만 올립니다. 버그 수정은 잘못된 내부 기능을 고치는 것이라 정의합니다.

5. 1.0.0 버전은 공개 API를 정의합니다. 이후의 버전 번호는 이때 배포한 공개 API에서 어떻게 바뀌는지에 따라 올립니다.

6. 공개 API에 기존과 호환되는 새로운 기능을 추가할 때는 반드시 부버전 Y( x.y.z | x > 0 )를 올립니다. 공개 API의 입무를 앞으로 제거할 것으로 표시한 경우에도 반드시 올리도록 합니다. 내부 비공개 코드에 새로운 기능이 대폭 추가되거나 개선사항이 있을 때도 올리 수 있습니다. 부버전을 올릴 때 수버전을 오릴 때만큼의 변화를 포함할 수도 있습니다. 부버전이 올라가면 수버전은 받드시 0에서 다시 시작합니다.

7. 공개 API에 기존과 호환되지 않는 변화가 있을 때는 반드시 주버전 x (X,y,z | X > 0)를 올립니다. 부버전이나 수버전급 변화를 포함할 수 있습니다. 주버전 번호를 올릴 때는 반드시 부버전과 수버전을 0으로 초기화 합니다.

8. 수버전 바로 뒤에 붙임표(-)를 붙이고 마침표(.)로 구분된 식별자를 더해서 정식 배포를 앞둔 (pre-release) 버전을 표기할 수 있습니다. 식별자는 반드시 아스키(ASCII) 문자, 숫자, 붙임표로만 구성한다[0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 합니다. 숫자 식별자의 경우 절대 앞에 0을 붙인 숫자로 표기하지 않습니다. 정식배포 전 버전은 관련한 보통 버전보다 우선순위가 낮습니다. 정식배포 전 버전은 아직 불안정하며 연관된 일반 버전에 대해 호환성 요구사항이 충족되지 않을 수도 있습니다. 예: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.

9. 우선순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할지를 나타낸다. 우선순위는 반드시 주, 부, 수 버전, 그리고 정식배포 전 버전의 식별자를 나누어 계산하도록 한다 
	1. 예: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.  
	2. 예: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.





### 언제 1.0.0을 배포해야 할지 어떻게 알 수 있나요?

소프트웨어가 실 서비스에 쓰이기 시작했다면 이미 1.0.0이라고 여길 수 있습니다. 사용자들이 믿고 쓸 수 있는 안정한 API가 있다면 1.0.0일 것입니다. 하위 버전 호환성에 대해 우려하기 시작했다면 이미 1.0.0일 수 있습니다.

###   유의적 버전 짓기가 신속한 개발과 빠른 이터레이션에 방해가 되지는 않나요?

주버전 0이 신속한 개발을 위한 것입니다. 만약 API를 매일같이 바꾸고 있다면 0.y.z 버전을 쓰거나 별도의 다음번 주버전 배포를 앞둔 개발 브랜치를 써야 합니다.



### 부버전을 올리는데 실수로 호환되지 않는 변경이 들어갔다면 어떻게 해야 하나요?

유의적 버전 명세를 어겼다는 사실을 알게 되면, 즉시 문제를 해결하고 호환성이 깨진 부분을 복구해서 새 부버전을 배포합니다. 이 경우라도 이미 배포된 버전을 변경해서는 안 됩니다. 필요한 경우라면 문제가 되는 버전을 문서로 표시해서 사용자들로 하여금 주의하도록 합니다.


### 제거하는 기능들에 대해서는 어떻게 할까요?

기존의 기능들을 사용하지 못하게 없애는 것은 소프트웨어 개발과정의 자연스러운 일부분이며, 때로는 앞으로 나아가기 위해 필수적인 일이기도 하다. 공개 API의 일부를 제거하고자 하다면 다음의 두 가지 일을 해야 한다: (1) 문서를 업데이트해서 사용자들에게 변화를 알리도록 한다. (2) 해당 기능이 제거될 거라 표시된 새 부버전을 적절한 시기에 배포한다. 새 주버전에서 완전히 기능을 제거하기 전에, 제거될 것이라 표시한 부버전 배포를 최소한 한 번은 진행해서 사용자들이 원활하게 새로운 API를 사용할 수 있도록 해야 한다.



### 유의적 버전을 확인할 수 있는 정규식(RegEx)이 있나?

두가지 방법이 있다. 첫번째는 캡처 그룹 이름 지정 방식의 정규식이다(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python, Go 지원).

See: [https://regex101.com/r/Ly7O1x/3/](https://regex101.com/r/Ly7O1x/3/)

```
^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
```

두번째는 캡처 그룹 이름 지정 방식을 지원하지 않는 경우의 정규식이다.

See: [https://regex101.com/r/vkijKf/1/](https://regex101.com/r/vkijKf/1/)

```
^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\
```
